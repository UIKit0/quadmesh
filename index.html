<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Projects</title>
    <meta charset="utf-8">
    <meta name="author" content="Philip Rideout">
    <link rel="shortcut icon" href="http://prideout.net/favicon.ico">
    <link href="style.css" rel="stylesheet">
  </head>
  <!--body style="background:rgb(0,64,128);color:rgb(220,220,220)"-->
  <body style="color:rgb(220,220,220)">

    Start.
 
    <div id="demo1" class="outerbox">
    <div class="boxarea">
      <h1 style="margin-top: 0px"><b>0</b> Blend shapes</h1>
      <p>Two position VBOs are bound and the vertex shader lerps between them, given a uniform variable (<b>time</b>) for the blending factor.<p>
      <p>Additionally, a geometry shader converts each incoming <b>lines_adjacency</b> primitive into a <b>line_strip</b> with five vertices, which walks around the quad.  Note that this results in overdraw between adjoining quads.</p>
    </div>
    </div>

    <!------------->
    
    <div id="demo2" class="outerbox">
    <div class="boxarea">
      <h1 style="margin-top: 0px"><b>1</b> Simple facets</h1>
      <p>Again, two position VBOs are bound and the vertex shader lerps between them.  In this case, the geometry shader converts each incoming <b>lines_adjacency</b> primitive into a <b>triangle_strip</b> with four vertices.  It also computes a facet normal by crossing two edge vectors.</p>
      <p>Additionally, the fragment shader computes simple lighting, given the surface normal generated by the geometry shader.</p>
    </div>
    </div>

    <!------------->
    
    <div id="demo3" class="outerbox">
    <div class="boxarea">
      <h1 style="margin-top: 0px"><b>2</b> Transform feedback</h1>
      <p>This time we use two passes: the first pass blends the two position VBOs and writes the result into a GPU-only buffer.  The second pass reads this buffer and draws a point cloud from it.</p>
    </div>
    </div>

    <!------------->
    
    <div id="demo4" class="outerbox">
    <div class="boxarea">
      <h1 style="margin-top: 0px"><b>3</b> Centroids</h1>
      <p>This uses two passes with transform feedback to draw the centroid of each animated quad.  But, it doesn't use geometry shaders or <b>lines_adjacency</b> to draw the quads.  Instead it does an "inverse DrawElements" by calling <b>DrawArrays</b> with <b>POINTS</b>, placing index data in an ivec4 attribute and position data in a texture buffer.</p>
    </div>
    </div>

    <!------------->
    
    <div id="demo5" class="outerbox">
    <div class="boxarea">
      <h1 style="margin-top: 0px"><b>4</b> Smooth normals</h1>
      <p>In the first pass, we compute facet normals into a transform feedback buffer using a simple geometry shader.<p>
      <p>In the second pass, we bind the facet normals as texture buffer <b>0</b> and an <i>inverse mapping</i> as texture buffer <b>1</b>.  This is just a mapping from verts to quad indices (the inverse of the traditional index buffer).  In the vertex shader, we find adjoining faces using the inverse mapping, summing up their facet normals and computing an average.</p>
    </div>
    </div>

    End.

  </body>
</html>
